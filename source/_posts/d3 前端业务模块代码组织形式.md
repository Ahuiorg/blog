---
title: d3 前端业务模块代码组织形式
abbrlink: 4288208203
date: 2022-07-11 14:16:56
---

### 如何打造更稳健的前端业务模块代码组织形式

### 文章出处：[如何打造更稳健的前端业务模块代码组织形式](https://cloud.tencent.com/developer/article/1833272)



业务系统和一般的应用有非常大的不同，一般的应用以提供给公司/企业外的用户（消费者、普通玩家）提供服务，以完成2C的销售目的，而业务系统一般是2B或者自身消费的模式，完成的是自身业务的管理目标。所以，应用侧重服务，业务系统侧重管理。两者的不同，导致我们对项目开发中，代码的组织方式会有差别。2C应用要满足大量用户在使用时的舒适性，因此要提高项目中有关性能、用户体验、效果等方面的要求，以吸引用户付费。但业务系统则稍有差别，虽然系统的使用体验也很重要，但是不是占最重要的部分，业务系统最重要的部分，是必须保证用户看到的数据、流程等，必须与真实的业务、业务流程一致，否则会带来自身利益的损失，因此，在稳健性、安全性等方面要求更高。

本文主要站在稳健性这个角度，试图阐述，在业务系统中，如何去安排或组织我们的（前端）代码，才能保证符合业务系统特征要求，且有利于长期可持续维护下去。由于谈系统过大，那么，本文只立足于一个业务模块来进行阐述。

## 什么是业务模块？

首先，什么是业务系统？在这之前，又必须回答什么是业务？业务（Business）专指商业活动，是实现企业生产到利益回收的一个环节，它的总和，构成了该企业盈利活动的整个流程。一般而言，我们所指的业务是企业商业活动中的一个部分，有的甚至小到一个环节，例如“结算”这个环节。业务系统则是辅助这些商业活动的计算机在线系统，以信息化的形式管理和决策企业的商业活动（理论上没有业务系统企业也能运转，但信息化社会没有业务系统会让企业寸步难行）。

大部分情况下，业务系统会尽可能多的囊括企业的业务环节，其目标是将企业的所有商业管理在线化，完成除必须在线下完成的实体业务之外的所有管理活动。而且，通过业务系统的数据积累，可以让企业基于已有数据进行深入决策，比只有线下管理的竞争对手高出多个维度。企业的管理者和员工使用业务系统，参与到企业的各个业务环节，参与形式各有不同，根据员工的角色来决定，比如有的员工不接触系统界面，只通过工卡完成各项流程的录入，有的员工则需要完成在线申请或审批，有的员工需要使用复杂的第三方工具完成系统录入等等。

业务模块，是以业务系统的建设者（领域专家、系统工程师等）的角度看待业务系统时，将庞大的业务系统，按照某个业务活动的边界，进行划分的某个单元。但是技术上，一般一个模块还是粒度比较大的单元。一般而言，业务模块囊括了系统关于该业务的所有内容，且和其他业务有明显的界限，理论上，可以在脱离了其他业务模块的情况下独立运行。

有了以上的认知，我们就知道，我们需要掌握企业在某个业务中，不同的参与者都是如何工作的。在该业务模块没有上线到业务系统中时，没人能明确的告诉你这个业务模块应该长什么样子，你需要走访业务的参与成员，了解他们实际是怎么工作的，然后再思考，如果要将这些工作迁移到线上，应该关注哪些方面，是用户的操作形式？是界面的友好风格？是信息的准确？但是应该注意一点，如果业务系统致使工作效率降低，那么说明设计该系统的人没有真正掌握企业商业活动的核心要点。

## DDD领域驱动设计

DDD（Domain-Driven Design）是帮助工程师，应对复杂业务系统设计和开发的思想武器和方法论。它指导了我们如何去和领域专家（熟悉业务的负责人）进行沟通，如何和他们找到一门共通语言，并基于该语言构建一套关于领域知识的图谱，并且是按照我们做系统设计的思路构建这套图谱。

建模是DDD的核心方法论，你需要去区分一个业务中的各个概念，为不同的概念建立不同类型的模型，并且找到它们之间的关系，通过建模，建立起我们编程的基础工程，后续所有的开发，都是在这些模型的基础上完成的。

## 前后端有别

自从前后端分离流行之后，DDD从某些技术层面上已经过时了。在传统系统开发中，系统大部分技术分布在后端即底层的基础建设上，用于[人机交互](https://cloud.tencent.com/product/xiaowei?from=10680)的表现层所占份额很小，甚至只是后端系统中输出的那么末梢节点，是花费时间最少的部分。而现代系统开发前后端分离之后，一套系统需要依赖前后端两个团队完成，这导致原本可以在排除其他业务模块之后可以独立运行的业务模块，现在不可能存在，因为现在的架构模式，导致前端代码一次性囊括所有模块，而后端代码模块间也具有较高的耦合，已经不可能回到以前一个模块的代码可以完全自治的模式下了。

基于新的架构，前端和后端对待一个业务模块的态度有了很大的不同。对于后端而言，模块相对来说还比较清晰，沿用旧的设计思路，模块的各个功能也能保持一定的高内聚。甚至，由于将视图层丢出去，后端甚至不需要考虑视图层的问题，只需要保证业务的数据准确和业务的流转准确即可。对于视图层，后端只需要一股脑将每一个功能所需要的数据（VO）以JSON的形式提供Restful接口即可。

对于前端而言，其实经历了多个阶段。起初，前端作为页面的处理方，主要是提供js脚本，完成一些特定的后端无法完成的交互效果，例如一些建议的滑动下拉效果，一些悬浮效果等，由于这些效果需要js编写，而后端开发人员不熟悉，就不得不由前端人员完成。之后，随着ajax技术兴起，前端路由技术的出现，页面交互效果开始变得丰富，无刷新的效果成为web应用的主流形式，使得后端人员参与前端工作的可能性越来越低，前端逐渐从作为后端末梢环节的地位独立出来，通过ajax或其他http交互方式，完成与后端的分离。

现在，我们的核心问题是：前端怎么对待业务模块？

一种成熟的方式是将业务模块组件化，这里的组件是具有高内聚设计的业务组件。2017年我在Morningstar工作的时候，就已经在采用这种方案。和现在的react、vue组件不同，当时我们基于backbone作为框架开发组件，一个组件基于一些数据点完成一个具体的业务（基金数据分析）。这个组件在交付时，需要同时交付前端和后端代码到不同的平台中，作为对应产品的一部分。组件的形式是一种不错的形式，包括我后面要推荐的方案，本质上也是交付组件。

但是，组件不是唯一的业务模块交付形式。我在业务中还使用angularjs作为框架开发应用，一般情况下，我们会根据路由来划分模块，一个模块拥有相同的路由根地址，模块内的各个功能或处理节点都是该路由的子路由。但是，它的模板、controller、service、样式文件被放在不同的目录下管理，虽然在前端的运行效率变高了，但是对于业务模块而言却变得高耦合低内聚。可能angular的开发团队意识到这个问题，angular2之后，也就是新的基于typescript的angular框架不在以这种模式对待业务模块，新的框架下，一个module的相关代码被聚合在一起，并且形式上以组件的形式导出，可以说实现了业务的高内聚，业务间的低耦合。

## 稳健的前端业务模块形式

Angular的module组织形式，我认为是比较优秀的组织形式。除了代码本身的组织形式之外，我们还要去看业务模块在设计上的特征，是否有利于为我们提供一定的灵活性，可为将来实现长期可持续迭代更新创造条件。

那么，怎么样设计业务模块呢？我提倡一种分层的理念。将业务模块分为数据层、表现层和逻辑层。这也是angular尝试践行的，它首先提供了可在编译时实现抽象的模板；其次提供了依赖注入的服务层为模块提供视图之外的其他能力，我们可以在服务层做很多事情，比如建立模型，但是它没有提供这方面的指导（，所以在其他文章中，我们不认为angular是完整的MVC框架，因为它在M层无所作为）；最后，它内置了基于rxjs的流式数据（状态）管理，基于管道的处理方式，可以让交互和状态的流动可以自由组合，使用起来非常灵活。但是，正如我提到的，它没有提供有关分层理念的更深入的指导，它提供了各种工具，让你自己选择是否使用，以及如何使用这些工具来编写出可长期维护的代码，完全由你的设计或架构能力决定。

而我则希望提供用于编写出明确分层概念的范式，就像多年前我们写后端服务时，需要进行分层管理一样，我希望在前端践行DDD的理念。但同时又有别于后端的DDD，前端不需要永久存储数据，每一次刷新浏览器，我们都可以通过api接口拿到需要的数据，而且从api请求数据和从[数据库](https://cloud.tencent.com/solution/database?from=10680)查询数据也有一定的差别。我们要构建具有DDD通行理念的，带有前端特色的建模体系。

## 前端建模

如果你使用vue组件，你会有一种为视图撰写模型的感觉，即ViewModel，它一定指向视图层（界面与用户交互）。但如我在多个场合提到的一样，vue组件是纯视图层的要件，如果你把有关业务的代码，写在vue组件中，你的代码将会是业务逻辑和视图逻辑混杂在一起的代码，你将无法在后来的维护中区分和把握到底要改业务逻辑还是改交互逻辑。实际上，这种操作是很多初级前端的惯用手法，因为大部分初级前端的编程习惯，都是随着意识流，按线性的思维写代码。而真正有经验的工程师，一定会在开始写代码之前先思考将要写作的代码，哪些是用于定义业务对象的，哪些是用于控制数据流的，哪些是为了完成界面渲染的，哪些是为了完成用户交互的等等。而这些思考，用一种思想来概括就是“分层思想”或者叫“Layered Architecture”。

有了分层思想之后，开发者才不会认为抽象出业务模型是一件麻烦的事。是的，很多初级前端觉得自己写的代码非常舒服，并且认为前端建模或把一些不属于视图层的东西提炼出去，是一件增加复杂度，使代码难读难维护的事。而实际上，由于他们只关注当下快速实现，而不用考虑可持续维护的问题，所以认为自己的实现是最优解。但往往有些系统，根本不应该让一个经验并不丰富且自以为是的初级前端来写，而应该由经验丰富的工程师来完成。两者之间的差距，会使得系统后续的发展呈现截然不同的效果。但讽刺的是，经验不足的开发者进入这样的项目组之后，反而认为自己写的粗糙的代码应该推广开替代已经成熟的体系，因为他觉得自己的代码可以一口气读完，是好代码。然而，现实是，当他们2个月之后回头看自己的代码，发现根本无法改动，或者要实现新功能非常困难，因为之前写的代码是线性的过程式代码，稍有调整，就需要把这条线重新切断再想办法连起来。所有的一切，都会在实践中被检验出来。分层开发，势在必行。

前端业务模型分为两类：一类是用于展示的模型，一类是用于数据提交（表单）的模型。后者在复杂度上会比前者高出一个等级。

你可能会有疑问，不都是业务模型么，怎么还区分用于展示的和提交的？这可能是前端的特殊之处。后端应用，提交数据到数据库时，具有特定的约束，但是在输出到前端时却没有约束，因此，后端把大部分工作都投入在对数据库有写入动作的业务逻辑上，而丢给前端的数据，基本上不需要按照视图层的逻辑建模，只要一股脑把数据丢给前端即可。但是前端则不同，视图层具有复杂的交互逻辑，而这些交互逻辑依赖业务对象的特征，比如当这个业务对象处于什么样的一个状态时，才能点击某个按钮触发一个流转业务。因此，在展示/交互这个层面，前端也需要建模。而提交数据就更不用说了，前端业务表单本身就是极为复杂的一种场景，不建立模型，根本无法对一个表单所要表达的业务对象完成清晰的创建或更新处理。

## 如何建模？

讲了那么多，那么到底应该如何实施前端建模呢？作为工程师，我们必须掌握一定的方法论，在理论上对我们的设计有一定的自信，才能确保我们的建模方式是对的。DDD为我们提供了建模的方法论，它提供了多个方案（Scheme），比如Entity, Value Object, Service, Modules, Aggregate, Factory, Repository等等，这些都是用来构造模型的方案。

这么多方案，实际上本质要解决两个问题：

- 核心
- 边界

我们要对业务进行建模，首先要抓住该业务的核心是什么。例如银行转账这个业务，它的核心是什么？是转账的金额，还是账号？它的边界又是什么？例如在转账这个业务中，我是否需要去把两边账号的消费记录拉出来看看？这些，都是我们要在建模的时候解决的问题。DDD告诉我们的方法论，是不要自己闭门造车，不要从开发人员的角度去设计一个系统，而是要找领域专家（对该业务的实操了如指掌的人）进行了解，建立自己对该业务的知识体系，并且和领域专家一起敲定有关这个业务各个细节的模型体系。

回到我们前端。我们实际上要找到这个业务中，存在那些对象，收集到所有对象之后，去一个一个的观察它们，如果它是业务逻辑中的关键对象，就要使用Entity的方案，对它进行细致的深入的描述，如果它是一个次要的或者说固定不变的或者一次性用完的对象，那么就可以使用Value Object的方案（也就是一个普通的对象）。有了这些对象之后，还需要有一个东西把它们聚合在一起，这时我们可以使用Aggreate的方案。在这些对象之间，还可能出现一些动作（动词，非静态的），此时我们可以使用Service和Factory的方案。我们还需要和服务端交互，拉取数据，填充到模型中，形成更丰富的细节，此时我们可以采用Repository的方案。

不要被这么多的名词吓到，本质上，放到前端的语境下，你就是需要去创建一些类，并处理好这些类在真实被使用时，它们之间的约束逻辑等等。

## 建模实践

既然本质上 是去建立类，那么接下来我们就来看一看如何利用前端的工具js来完成模型的建立。在这之前，我们不得不承认，js不是一门能像java一样写出健壮的系统的语言。它有自己的语法特征，而这些语法特征导致我们在完成建模时，需要采取一些非常手段。比如我，就是利用class的static属性来完成模型上元数据的定义。

```javascript
class Account {
  static default = ''
  static type = 'numeric'
}

class Amount {
  static default = 0
  static type = 'number'
}

class TransferModel {
  id = ''
  static from = Account
  static to = Account
  static amount = Amount
}
```

上面这段代码仅仅是我用来说明建模的一个思路，我没有在生产环境用过这样的代码。首先，我们定义了两个类：Account账户, Amount金额。这两个类具有类似的结构，因为它们是用来描述这个对象应该具备的一些特征，比如Account这个对象应该是一个数字字符串，而Amount应该是一个数字。其次，Transfer是一个包含了三个字段的对象，每个字段都对应一个建好模的对象。我们在使用时，主要是去使用Transfer实例化出来的对象，这个对象应该具备3个字段，且每个字段应该具备哪些规则（约束）都是提前规定好的。

上面是我们对转账这个业务中的对象进行建模。实际上，我们并没有完成转账这个业务，我们需要把数据发送给api，以真正完成转账。所以，我们要在对象之外，建立一个服务，用于完成这个业务。

```javascript
class TransferService {
  submitTransfer(id, data) {
    ...
  }
  getTransfer(id) {
    ...
  }
}
```

这也非常容易理解，我们通过两个方法来完成和API接口的交互，从而使得这个业务完成前后端对接，使它在整个系统层面生效。同时，我们还提供了一个接口getTransfer，它将用于在用户查看自己的转账记录的时候，还原数据。

但上面这些还不够，我们需要有一个东西，把它们串联起来，它们才能真正工作。

```javascript
class TransferController {
  static model = TransferModel
  static service = TransferService

  async init(id) {
    const data = await this.service.getTransfer(id)
    this.model.setData(id, data)
  }

  async submit() {
    const data = this.model.getData()
    await this.service.submitTransfer(this.model.id, data)
  }
}
```

这样，我们就模型和服务串起来了。我们可以从这三块代码中，大致看出关于转账这个业务的实际逻辑。但是，我们忽略了另外一个东西，就是我们现在还没有界面，我们还没有提供给用户怎么进行操作后完成这个转账。因此，我们还需要补全这个部分。

```javascript
class TransferView extends React.Component {
  controller = new TransferController()
  componentDidMount() {
    const { id } = this.props
    this.controller.init(id)
  }
  render() {
    return (
      <button onClick={() => this.controller.submit()}>transfer</button>
    )
  }
}
```

这样，我们就将视图和模型最终串了起来。也实现了我们最初关于分层的想法。通过分层架构（Layered Architecture），我们的代码被以不同层的不同理念进行组织。有关模型的东西，全都且只在模型层处理，我们不需要考虑外部将会如何使用它，理论上可以表述为“内存实体不需要考虑外层环境”的Clean Architecture，因此，我们只需要考虑，我们的建模是否符合真实业务的需要。这样的代码组织，将颠覆我们传统前端开发的一些经验，然而，这种颠覆显得没有什么惊喜，它看上去复杂度增加了，我们反问一句自己，我们是为了分层而分层，还是为了这样分层写出的代码，将有助于我们区分代码块功能，以利于我们的项目在两年三年的持续迭代维护中，有比较清晰的代码组织，从而让我们的维护更加有效？

## 提炼关系表

关系表是指在某个业务逻辑中，涉及多个业务对象，它们之间的存在不同情况下的不同联系，所最终组成的一个Object对象。这样说过于抽象，我们用实际的案例来说明问题。

在上述转账系统中，存在着这样的内在逻辑，当用户X信用等级为1时，他不能向客户类型为A类的用户转账，因为可能存在信用风险。此时，实际上，我们要构建一张用于表达信用、客户类型和转账权限之间的关系表，在我的设计里，转账权限是结果，因此，它是值，而信用、客户类型是条件，因此，产生的表可以按如下写：

```javascript
{
  1: {
    A: false,
    B: true,
  },
  2: {
    A: true,
    B: true,
  },
}
```

上面的关系表表示了如下关系：信用为1级的用户，不能向A类用户转账，但可以向B类用户转账；信用为2级的用户，可以向A和B类用户转账。

一般来讲，关系表会非常繁琐，因为它要枚举大部分可能性（一个技巧是，不需要列出false的情况，只需要列出true的情况的关系即可），所以感觉节点会很多。但是，它的用处却非常大，你可以使用它避免一大堆的if...else。比如上面这个场景。我们有两种选择，一种是将这个关系写在模型中，另外一种是写在控制器中。例如：

```javascript
class Credit {
  static default = 1
  static type = enumerate([1, 2])
}

class Stratum {
  static default = 'A'
  static type = enumerate(['A', 'B'])
}

class AccountModel {
  static credit = Credit
  static stratum = Stratum

  canTransfer(toAccount) {
    if (this.credit === 1) {
      return ['B'].includes(toAccount.stratum)
    }
    else {
      return true
    }
  }
}

class TransferModel {
  static from = AccountModel
  static to = AccountModel

  transfer() {
    if (this.from.canTrasfer(this.to)) {
      ...
    }
  }
}
```

你看，我们在canTransfer方法中通过if...else来进行判断，看上去也是可以的，但是，这里有一个问题是，这段代码无法让我们洞悉业务的详细细节，它像是一段无法被看透的程序，而不是一段业务的描述。接下来我们用关系表来改造它：

```javascript
canTransfer(toAccount) {
  return relationship[this.credit]?.[toAccount.stratum]
}
```

多么简单的一句话，而这里的relationship就是我们上面我们列举的关系表。关系表是静态的，不仅程序的运行性能会更好，同时，我们阅读关系表（需要增加对键的含义注释）来掌握业务中都有哪些情况，我们熟知了业务，才能在将来的调整时，将关系表中的true改为false即可。

### 基于React的DDD框架

但以上仅仅是一个思路，要让它工作起来，还有非常多的工作要做。幸运的是，我已经帮你做了这项工作，我发布了开源的 tyshemo（https://github.com/tangshuang/tyshemo）模式库和 nautil（https://nautil.js.org/）框架，tyshemo 帮助你完成核心的模型层，nautil 则是基于 tyshemo 提供了完整的 service 和 controller 建模，以及提炼了业务交互的相关编程范式，你可以使用它完成DDD思路的整个链路的实践，同时，又不失去基于react进行开发的乐趣。你可以在这里（https://github.com/tangshuang/nautil-cli/tree/master/lib/templates/src/app/modules/home）看到一份完整的代码示例。

![img](https://ask.qcloudimg.com/http-save/yehe-2226939/rjlywuaz7f.png?imageView2/2/w/1620)

面对一个业务模块，我们会把和它相关的所有代码文件放在一个目录下进行管理（除一些需要公用的资源除外）。我们首先要对业务进行建模，如果是简单的一两个模型，我们只需要建立一个.model.js来完成，而如果是一个比较复杂的体系，我们可以创建一个.model文件夹，放置所有相关模型文件，比如上图示例中，我们可以创建home.model文件夹来管理。建模的同时，我们就会在必要的时候，为模块创建service，规则也是一样。完成建模之后，我们需要撰写控制器controller，在一个controller内部，你需要引入model和service，nautil的Controller会自动帮你实例化它们，并且做好观察。

除了把model和service串联起来，controller还有什么用呢？你还可以在controller内建立基于模型的交互，我称之为“无视图的交互模型”。因为对于前端应用来讲，业务除了数据逻辑之外，往往还有交互逻辑，比如“点击这个按钮之后，弹出一个对话框询问用户是否确认转账，如果用户点确认，那么执行转账”，这段交互描述里面，没有确切的告诉你弹出框应该长什么样子，用什么颜色，字体多大等等，它只描述了有关业务的交互部分，这个部分与布局和样式无关，是纯粹的描述和业务相关的交互效果。得益于react的抽象能力，我们可以直接在controller中，使用jsx完成纯交互的部分，并以组件的形式作为controller的接口提供给外部使用。这样，有关业务的一切逻辑，我们就通过controller串联model和service，在一个模块内，脱离布局，完成了。完成controller之后，我们才开始布局开发，布局开发也就是react组件的日常开发，由于我们在controller中导出了交互组件，而这些交互组件已经涵盖了大部分业务逻辑，所以，我们可以做到布局组件和业务无关，是纯粹的布局和样式。

基于这样的设计，我们在后续的开发中，还可以加入一些特殊的逻辑，例如，我们一个业务模块，可能在PC端也可能在手机端使用，那么，此时，我们只需要重写布局组件，而无需再写业务逻辑相关的代码。更多的思想，需要你更深入的了解nautil，以及尝试使用它作为主力开发工具之后，慢慢体会。

## 结语

本文虽然标题是谈如何打造前端的模块代码，但本质上，详细的阐述了我关于DDD的思想的理解，以及自己在DDD的思想基础上构建的一套代码管理范式，并且以前端框架的形式组织起来。我相信，如果你也是在编写复杂的业务系统，并且遇到一些瓶颈的话，一定能从本文中有所收获。当然，由于前端的特殊性，我们不能照搬DDD，需要有所变通。我写框架，也只是一种探索，并不代表它是唯一的一种形态。随着产业互联网时代的到来，前端逐渐从大众型交互应用，转向企业型业务系统应用，这是大势所趋，也是所谓“互联网下半场”前端立足之本。本文抛砖引玉，相信站在前端的角度去看待复杂业务（专有领域）的研究会越来越多。究会越来越多。