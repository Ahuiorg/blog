---
title: 领域驱动设计
date: 2022-07-11 14:16:56
---



### 相关概念

领域驱动设计（domain-driven-design）是软件代码的结构及语言需要符合**业务领域**中的习惯用法

领域驱动设计可以将实现对应到持续进化的模型

领域驱动设计的前提是：

- 把项目的主要重点放在核心领域（core domain）和领域逻辑
- 以领域中的模型为基础，进行复杂的设计
- 让技术人员以及领域专家合作，以迭代方式来完善特定领域问题的概念模型

##### **上下文（Context）**

情境，脉络，上下文。比如：电子商务系统。

##### **领域（Domain）**

知识、影响、活动。客户使用软件要处理的问题种类即为软件的领域。

##### **模型（Model）**

一类描述域的不同方面并可用于解决相关问题的系统化的抽象

##### **通用语言（Ubiquitous Language）**

一种领域专家使用，为了描述[域模型](https://zh.wikipedia.org/wiki/領域模型)而构造的语言，以减少沟通成本。

> 理想情况下，只有一个统一的模型。 但是通常情况下都无法实现，因此在实践中通常分成多个模型。

##### **上下文环境**

任何大型项目都有多个模型。 然而，当基于不同模型的代码相结合，软件变得越来越多，不可靠，并且难以理解。 团队成员之间的交流变得越来越难。 模型的使用情境变得越来越不清晰。

因此：需要明确定义模型适用的上下文，并且根据团队组织，应用程序特定部分的使用情况以及代码库和数据库模式等物理表现明确设置边界。 保持模型在这些范围内严格一致，并且不被外部的问题影响。

##### **持续集成**

当愈多人在相同的有限背景下工作时，模型就愈应该分裂。 团队越大，问题就越大，即使只有三四个人也会遇到严重的问题。 然而，将系统分解为更小的环境最终会失去一个有价值的集成和一致性。

因此：创建一个经常合并所有代码和其他实现工件的过程，用自动化测试快速标记碎片。通过持续地运用统一术语去夯实随着概念在不同人的头脑中的演变而逐渐形成对模型的共同观点。

##### **上下文关系**

在缺乏全局认识的情况下，个别有界上下文会留下一些问题。 其他模型的背景可能仍然是模糊不清的。 其他团队的人不会意识到上下文的界限，并且会不知不觉地做出模糊边缘或使连接复杂化的变化。 当连接必须在不同的上下文之间进行时，它们往往会相互渗透。

因此：确定项目中正在使用的每个模型并定义其上下文环境。 这包括非面向对象子系统的隐式模型。 命名每个上下文环境，并将其命名为通用语言的一部分。 描述模型之间的关联点，确保任何用于共享交流的词语都有清晰明确的含义。 映射现有的情形。





### 前端建模

如果你使用vue组件，你会有一种为视图撰写模型的感觉，即ViewModel，它一定指向视图层（界面与用户交互）。但如我在多个场合提到的一样，vue组件是纯视图层的要件，如果你把有关业务的代码，写在vue组件中，你的代码将会是业务逻辑和视图逻辑混杂在一起的代码，你将无法在后来的维护中区分和把握到底要改业务逻辑还是改交互逻辑。实际上，这种操作是很多初级前端的惯用手法，因为大部分初级前端的编程习惯，都是随着意识流，按线性的思维写代码。而真正有经验的工程师，***一定会在开始写代码之前先思考将要写作的代码，哪些是用于定义业务对象的，哪些是用于控制数据流的，哪些是为了完成界面渲染的，哪些是为了完成用户交互的等等。而这些思考，用一种思想来概括就是“分层思想”或者叫“Layered Architecture”。***

有了分层思想之后，开发者才不会认为抽象出业务模型是一件麻烦的事。是的，很多初级前端觉得自己写的代码非常舒服，并且认为前端建模或把一些不属于视图层的东西提炼出去，是一件增加复杂度，使代码难读难维护的事。而实际上，由于他们只关注当下快速实现，而不用考虑可持续维护的问题，所以认为自己的实现是最优解。但往往有些系统，根本不应该让一个经验并不丰富且自以为是的初级前端来写，而应该由经验丰富的工程师来完成。两者之间的差距，会使得系统后续的发展呈现截然不同的效果。但讽刺的是，经验不足的开发者进入这样的项目组之后，反而认为自己写的粗糙的代码应该推广开替代已经成熟的体系，因为他觉得自己的代码可以一口气读完，是好代码。然而，现实是，当他们2个月之后回头看自己的代码，发现根本无法改动，或者要实现新功能非常困难，因为之前写的代码是线性的过程式代码，稍有调整，就需要把这条线重新切断再想办法连起来。所有的一切，都会在实践中被检验出来。**分层开发，势在必行。**

**前端业务模型分为两类：一类是用于展示的模型，一类是用于数据提交（表单）的模型**。后者在复杂度上会比前者高出一个等级。

你可能会有疑问，不都是业务模型么，怎么还区分用于展示的和提交的？这可能是前端的特殊之处。后端应用，提交数据到数据库时，具有特定的约束，但是在输出到前端时却没有约束，因此，后端把大部分工作都投入在对数据库有写入动作的业务逻辑上，而丢给前端的数据，基本上不需要按照视图层的逻辑建模，只要一股脑把数据丢给前端即可。但是前端则不同，视图层具有复杂的交互逻辑，而这些交互逻辑依赖业务对象的特征，比如当这个业务对象处于什么样的一个状态时，才能点击某个按钮触发一个流转业务。因此，在展示/交互这个层面，前端也需要建模。而提交数据就更不用说了，前端业务表单本身就是极为复杂的一种场景，不建立模型，根本无法对一个表单所要表达的业务对象完成清晰的创建或更新处理。





通过分层架构（Layered Architecture），我们的代码被以不同层的不同理念进行组织。有关模型的东西，全都且只在模型层处理，我们不需要考虑外部将会如何使用它，理论上可以表述为“内存实体不需要考虑外层环境”的Clean Architecture，因此，我们只需要考虑，我们的建模是否符合真实业务的需要。这样的代码组织，将颠覆我们传统前端开发的一些经验，然而，这种颠覆显得没有什么惊喜，它看上去复杂度增加了，我们反问一句自己，我们是为了分层而分层，还是为了这样分层写出的代码，将有助于我们区分代码块功能，以利于我们的项目在两年三年的持续迭代维护中，有比较清晰的代码组织，从而让我们的维护更加有效？













参考：

1. [维基百科](https://zh.wikipedia.org/wiki/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88)
2. [如何打造更稳健的前端业务模块代码组织形式](https://cloud.tencent.com/developer/article/1833272)

